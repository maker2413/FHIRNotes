#+TITLE: The HL7 Fast Healthcare Interoperability Resources standard

Now that we've wrapped up Part I, you should have a solid understanding of the
long journey the HL7 community took to arrive at the idea of modernizing
healthcare data exchange. We're now ready to dive into the core of this course -
the Fast Healthcare Interoperability Resources, or FHIR, standard.

To begin with let's go over what HL7 FHIR originally meant. Due to the fact that
HL7v2 had become outdated and HL7v3 had grown too complex to gain widespread
adoption, HL7 International - a nonprofit organization that develop healthcare
data standards - introduced a new specification called Fast Healthcare
Interoperability Resources, or FHIR.

FHIR is a modern, flexible approach to sharing healthcare data, built on widely
used web technologies such as JSON and RESTful APIs. It enables seamless access
to and integration of healthcare information across different systems and
applications. As a result, FHIR has been increasingly adopted by healthcare
organizations and technology vendors around the world.

Now, let's take a look back at how FHIR came to be. First, let's dive into the
concept of Resources for Health. Back in the early 2010s, the people developing
healthcare data standards were feeling the pressure to modernize. The Health IT
community was eager to move beyond the legacy HL7 version 2 standard and adopt
technologies that supported cloud computing, mobile applications, and modern web
integration. At the same time, broader tech innovations were influencing
expectations - take Facebook, for example. Developers could build apps that
seamlessly integrated with Facebook's platform using a simple, JSON-based API.

Inspired by these trends, a new initiative called Resources for Health, or RFH,
emerged around 2010 to explore a modern, web-friendly approach to healthcare
interoperability. Resources for Health was the brainchild of Grahame Grieve,
Ewout Kramer, and Lloyd McKenzie. Their goal was to explore what a modern HL7
specification might look like if they started from scratch - focusing on web
technologies and RESTful design principles. They introduced the concept of a
"resource", which refers to a small, self-contained piece of medical
information.

Let's briefly dive into how FHIR's modeling approach differs from earlier HL7
standards. Unlike HL7 version 2, which organizes information into reusable
message segments tailored for specific workflows, FHIR introduces a set of
modular healthcare "resources". These resources are designed to represent common
clinical and administrative concepts, and can be combined in flexible ways to
meet a wide range of use cases.

This resource-based approach gives a lot of flexibility and makes it easier for
different systems to communicate effectively. Take a look at this table for a
high-level comparison of these modeling approaches:
| HL7v2                | FHIR                         |
|----------------------+------------------------------|
| Segments             | Resource Types               |
| Model by combination | Model by composition         |
| Trigger event based  | REST, subscription, Document |
| Extensible           | Extensible                   |
| MLLP                 | RESTful API                  |
| ER7                  | JSON, XML, RDF               |

Respectively, unlike HL7 version 3, which followed a "model by constraint"
methodology, FHIR takes a compositional approach. In FHIR, use cases are
typically addressed by linking multiple resources together through
references. While a single resource might be sufficient for a simple scenario,
more commonly, resources are combined and tailored to meet specific clinical or
business requirements.

* What is FHIR really about?
  Well, at its core, FHIR is a set of specifications that define how healthcare
  applications exchange information.

  It outlines what data is shared, how it's shared, and how it should be
  managed. FHIR supports multiple approaches - known as exchange paradigms - for
  sharing data between systems, with a strong emphasis on using modern web
  technologies like RESTful APIs. One of the great strengths of FHIR is that
  it's designed to be implementer-friendly - simple to understand and
  straightforward to use. The entire FHIR specification is freely available
  online, making it highly accessible. That's a big contrast compared to
  standards like X12, which can be harder to obtain and work with.

  After more than a decade of discussion and development, the FHIR standard has
  come a long way. What began as a simple one-page website with fewer than 50
  sections and just 9 established, plus 22 proposed, resource types has grown
  into a comprehensive platform with nearly 3500 pages and around 140
  well-defined resources.

* FHIR Specification
  To reference documentation on the FHIR specification simply review
  [[fhir.org]]. When reviewing documentation on the FHIR specification note that any
  page marked as ~N~ stands for "Normative", which simply means that that
  section is considered stable and is unlikely to change. Any page marked ~TU~
  stands for "Trial Use", which indicates that the item is still under review.

* FHIR Resources
  If you've explored different FHIR resource types, you've probably noticed they
  share a common structure. This typically includes a unique identifier,
  metadata stored by the system, and other elements. FHIR actually uses an
  inheritance model - somewhat similar to what we discussed earlier with HL7
  version 3 and the RIM.

** FHIR Resource Type Framework
   At the core of every FHIR resource is the ~Base~ class, which doesn't contain
   any specific elements or restrictions. From there, we have a class called
   ~Resource~, which inherits from ~Base~ and introduces elements like a logical
   ID, metadata, and a few others. Building on that, the ~DomainResource~ class
   adds human-readable narrative support, allows for root-level extensions, and
   supports contained resources.

   Most commonly used FHIR resource types are built on ~DomainResource~ and are
   grouped into modules like ~Administration~, ~Clinical~, ~Medications~ and
   about 11 others.

   Now, here's an exception worth noting - the resource types ~Bundle~,
   ~Parameters~, and ~Binary~ inherit directly from ~Resource~, not
   ~DomainResource~. These three resources do not support root-level extensions,
   narratives, or contained resources. You can see this in the following image:
   [[./TypeFramework.png]]

   Let's jump into a quick Q&A session to go over some of the most common
   questions you might have.
   - Can a resource instance with an identifier element be used as a contained
     resource?
     - Yes, a resource with an identifier can be used as a contained resource,
       as long as there's a reference between the parent resource and the
       contained one. However, if the resource instance can be uniquely
       identified - such as by using a business identifier - it's generally
       better practice to represent it as a standalone resource.
   - Can a contained resource reference back to the parent or container
     resource?
     - Absolutely. The FHIR specification explicitly allows bidirectional
       references, meaning a contained resource can reference its parent
       resource.
   - Can a contained resource reference another contained resource within the
     same parent resource?
     - Yes, this is possible as well. Contained resources within the same parent
       can reference each other, as long as at least one of them is also
       referenced by, or references, the parent resource.
   - Can a contained resource reference another resource instance outside the
     parent or container resource?
     - This is indeed possible, but in practice, it requires indexing contained
       resource instances and may involve creating chained search parameters
       specific to the FHIR server you're using. Once this is done, you should
       be able to retrieve the parent container resource along with the
       referenced resource.

* FHIR Data Types
  As we mentioned earlier, at the core of FHIR is the ~Base~ class, which
  doesn't have any specific elements or restrictions. Unsurprisingly, this
  ~Base~ class serves as the foundation for all data types in FHIR.

  Moving specifically to data types, the next level is the ~Element~ class. This
  class introduces two key attributes ~id~ and ~extension~. You might have
  already guessed that any data type in FHIR can include extensions.

  Following that, we have the ~DataType~ class, which acts as the base
  definition for all data types. Its two main subclasses are ~PrimitiveType~ and
  ~BackboneType~. The primary difference between them is that ~BackboneType~
  includes the ~modifierExtension~ attribute.

  FHIR data types come in two varieties: ~primitive~ and ~complex~. ~Primitive~
  data types have a single simple property, while complex data types can contain
  multiple properties - each of which may itself be a ~primitive~ or another
  ~complex~ data type.

  You can see all of this in the following image:
  [[./DataTypes.png]]

** FHIR Extensibility
   Let's discuss an exciting and important topic the FHIR extensibility
   mechanism. Even if you're new to healthcare IT, you've probably noticed that
   no standard can fully cover every real-world data scenario or business
   process. The HL7 working groups recognized this early on. In earlier versions
   like HL7v2, the standard allowed local extensions of message types, trigger
   events, segments, fields, and data types. This approach has continued through
   HL7v3 and is now a core part of FHIR.

   As you may recall, all resources and data types derive from the ~Base~
   class. Both the ~DomainResource~ and ~Element~ classes include an extension
   element, which allows extensions to be added at the root level of a resource
   instance, as well as to individual elements, including those with ~primitive~
   data types.
