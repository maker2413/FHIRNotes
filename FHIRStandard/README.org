#+TITLE: The HL7 Fast Healthcare Interoperability Resources standard

Now that we've wrapped up Part I, you should have a solid understanding of the
long journey the HL7 community took to arrive at the idea of modernizing
healthcare data exchange. We're now ready to dive into the core of this course -
the Fast Healthcare Interoperability Resources, or FHIR, standard.

To begin with let's go over what HL7 FHIR originally meant. Due to the fact that
HL7v2 had become outdated and HL7v3 had grown too complex to gain widespread
adoption, HL7 International - a nonprofit organization that develop healthcare
data standards - introduced a new specification called Fast Healthcare
Interoperability Resources, or FHIR.

FHIR is a modern, flexible approach to sharing healthcare data, built on widely
used web technologies such as JSON and RESTful APIs. It enables seamless access
to and integration of healthcare information across different systems and
applications. As a result, FHIR has been increasingly adopted by healthcare
organizations and technology vendors around the world.

Now, let's take a look back at how FHIR came to be. First, let's dive into the
concept of Resources for Health. Back in the early 2010s, the people developing
healthcare data standards were feeling the pressure to modernize. The Health IT
community was eager to move beyond the legacy HL7 version 2 standard and adopt
technologies that supported cloud computing, mobile applications, and modern web
integration. At the same time, broader tech innovations were influencing
expectations - take Facebook, for example. Developers could build apps that
seamlessly integrated with Facebook's platform using a simple, JSON-based API.

Inspired by these trends, a new initiative called Resources for Health, or RFH,
emerged around 2010 to explore a modern, web-friendly approach to healthcare
interoperability. Resources for Health was the brainchild of Grahame Grieve,
Ewout Kramer, and Lloyd McKenzie. Their goal was to explore what a modern HL7
specification might look like if they started from scratch - focusing on web
technologies and RESTful design principles. They introduced the concept of a
"resource", which refers to a small, self-contained piece of medical
information.

Let's briefly dive into how FHIR's modeling approach differs from earlier HL7
standards. Unlike HL7 version 2, which organizes information into reusable
message segments tailored for specific workflows, FHIR introduces a set of
modular healthcare "resources". These resources are designed to represent common
clinical and administrative concepts, and can be combined in flexible ways to
meet a wide range of use cases.

This resource-based approach gives a lot of flexibility and makes it easier for
different systems to communicate effectively. Take a look at this table for a
high-level comparison of these modeling approaches:
| HL7v2                | FHIR                         |
|----------------------+------------------------------|
| Segments             | Resource Types               |
| Model by combination | Model by composition         |
| Trigger event based  | REST, subscription, Document |
| Extensible           | Extensible                   |
| MLLP                 | RESTful API                  |
| ER7                  | JSON, XML, RDF               |

Respectively, unlike HL7 version 3, which followed a "model by constraint"
methodology, FHIR takes a compositional approach. In FHIR, use cases are
typically addressed by linking multiple resources together through
references. While a single resource might be sufficient for a simple scenario,
more commonly, resources are combined and tailored to meet specific clinical or
business requirements.

* What is FHIR really about?
  Well, at its core, FHIR is a set of specifications that define how healthcare
  applications exchange information.

  It outlines what data is shared, how it's shared, and how it should be
  managed. FHIR supports multiple approaches - known as exchange paradigms - for
  sharing data between systems, with a strong emphasis on using modern web
  technologies like RESTful APIs. One of the great strengths of FHIR is that
  it's designed to be implementer-friendly - simple to understand and
  straightforward to use. The entire FHIR specification is freely available
  online, making it highly accessible. That's a big contrast compared to
  standards like X12, which can be harder to obtain and work with.

  After more than a decade of discussion and development, the FHIR standard has
  come a long way. What began as a simple one-page website with fewer than 50
  sections and just 9 established, plus 22 proposed, resource types has grown
  into a comprehensive platform with nearly 3500 pages and around 140
  well-defined resources.

* FHIR Specification
  To reference documentation on the FHIR specification simply review
  [[fhir.org]]. When reviewing documentation on the FHIR specification note that any
  page marked as ~N~ stands for "Normative", which simply means that that
  section is considered stable and is unlikely to change. Any page marked ~TU~
  stands for "Trial Use", which indicates that the item is still under review.

* FHIR Resources
  If you've explored different FHIR resource types, you've probably noticed they
  share a common structure. This typically includes a unique identifier,
  metadata stored by the system, and other elements. FHIR actually uses an
  inheritance model - somewhat similar to what we discussed earlier with HL7
  version 3 and the RIM.

** FHIR Resource Type Framework
   At the core of every FHIR resource is the ~Base~ class, which doesn't contain
   any specific elements or restrictions. From there, we have a class called
   ~Resource~, which inherits from ~Base~ and introduces elements like a logical
   ID, metadata, and a few others. Building on that, the ~DomainResource~ class
   adds human-readable narrative support, allows for root-level extensions, and
   supports contained resources.

   Most commonly used FHIR resource types are built on ~DomainResource~ and are
   grouped into modules like ~Administration~, ~Clinical~, ~Medications~ and
   about 11 others.

   Now, here's an exception worth noting - the resource types ~Bundle~,
   ~Parameters~, and ~Binary~ inherit directly from ~Resource~, not
   ~DomainResource~. These three resources do not support root-level extensions,
   narratives, or contained resources. You can see this in the following image:
   [[./TypeFramework.png]]

   Let's jump into a quick Q&A session to go over some of the most common
   questions you might have.
   - Can a resource instance with an identifier element be used as a contained
     resource?
     - Yes, a resource with an identifier can be used as a contained resource,
       as long as there's a reference between the parent resource and the
       contained one. However, if the resource instance can be uniquely
       identified - such as by using a business identifier - it's generally
       better practice to represent it as a standalone resource.
   - Can a contained resource reference back to the parent or container
     resource?
     - Absolutely. The FHIR specification explicitly allows bidirectional
       references, meaning a contained resource can reference its parent
       resource.
   - Can a contained resource reference another contained resource within the
     same parent resource?
     - Yes, this is possible as well. Contained resources within the same parent
       can reference each other, as long as at least one of them is also
       referenced by, or references, the parent resource.
   - Can a contained resource reference another resource instance outside the
     parent or container resource?
     - This is indeed possible, but in practice, it requires indexing contained
       resource instances and may involve creating chained search parameters
       specific to the FHIR server you're using. Once this is done, you should
       be able to retrieve the parent container resource along with the
       referenced resource.

* FHIR Data Types
  As we mentioned earlier, at the core of FHIR is the ~Base~ class, which
  doesn't have any specific elements or restrictions. Unsurprisingly, this
  ~Base~ class serves as the foundation for all data types in FHIR.

  Moving specifically to data types, the next level is the ~Element~ class. This
  class introduces two key attributes ~id~ and ~extension~. You might have
  already guessed that any data type in FHIR can include extensions.

  Following that, we have the ~DataType~ class, which acts as the base
  definition for all data types. Its two main subclasses are ~PrimitiveType~ and
  ~BackboneType~. The primary difference between them is that ~BackboneType~
  includes the ~modifierExtension~ attribute.

  FHIR data types come in two varieties: ~primitive~ and ~complex~. ~Primitive~
  data types have a single simple property, while complex data types can contain
  multiple properties - each of which may itself be a ~primitive~ or another
  ~complex~ data type.

  You can see all of this in the following image:
  [[./DataTypes.png]]

** FHIR Extensibility
   Let's discuss an exciting and important topic the FHIR extensibility
   mechanism. Even if you're new to healthcare IT, you've probably noticed that
   no standard can fully cover every real-world data scenario or business
   process. The HL7 working groups recognized this early on. In earlier versions
   like HL7v2, the standard allowed local extensions of message types, trigger
   events, segments, fields, and data types. This approach has continued through
   HL7v3 and is now a core part of FHIR.

   As you may recall, all resources and data types derive from the ~Base~
   class. Both the ~DomainResource~ and ~Element~ classes include an extension
   element, which allows extensions to be added at the root level of a resource
   instance, as well as to individual elements, including those with ~primitive~
   data types.

* FHIR Search Capabilities
  Searching for FHIR resource instances is a fundamental part of the FHIR
  standard, and it can be both exciting and a bit challenging. The challenge
  lies in the flexibility of FHIR. It's designed to strike a balance between
  being simple enough for everyday use, and adaptable enough to meet the demands
  of real-world clinical and business scenarios.

  Let's explore how data is exchanged. As you may recall, FHIR defines several
  mechanisms, called paradigms, to manage data exchange. There are four main
  ways to exchange data in FHIR:
  - REST
  - Documents
  - Messages
  - Services

  Of these RESTful interfaces are the most widely used, and much of it is now
  published as normative. It's important to note that FHIR servers can choose
  which interactions and resource types they support. To communicate this
  information, each FHIR server provides a CapabilityStatement - a special
  resource that outlines what that server can do.

  To request the CapabilityStatement, you can send a "capabilities" interaction
  request:
  #+begin_example
    GET [base]/metadata
  #+end_example

  In this case, the term "metadata" refers to an operation, but unlike other
  operations in FHIR, it doesn't use the dollar sign. Since FHIR servers can
  vary, they may support different resource types, search parameters, or even
  define custom search capabilities.

  FHIR Search is one of the most important features of the entire FHIR
  standard. It plays a crucial role in making it easy to find and retrieve
  healthcare information from a FHIR server. This helps clinicians make informed
  decisions, supports care coordination, and allows healthcare systems to run
  their business operations more effectively.

  Before we dive into details like modifiers, prefixes, or available search
  parameters, let's start by understanding the types of search parameters. As
  we discussed earlier, FHIR has primitive and complex data types. However, the
  search parameter types used in FHIR's search mechanism don't align exactly
  with those. They're designed to simplify implementation while maintaining
  consistent behavior across both simple and complex data types.

  Take a look at this table that shows how the search parameter types relate to
  FHIR data types:
  | Parameter Type | Primitive Data Type            | Complex Data Type                                 |
  |----------------+--------------------------------+---------------------------------------------------|
  | number         | integer, integer64, decimal    | ---                                               |
  | date           | date, dateTime, instant        | Period, Timing                                    |
  | string         | string                         | ---                                               |
  | token          | code, boolean, id, uri, string | Coding, CodeableConcept, Identifier, ContactPoint |
  | reference      | ---                            | Reference                                         |
  | composite      | ---                            | ---                                               |
  | quantity       | ---                            | Quantity                                          |
  | uri            | uri                            | ---                                               |
  | special        | ---                            | ---                                               |

  You might be wondering, "What about complex types like Address or HumanName?"
  Good question. In those cases, search parameters apply to the individual
  components of the complex type - each of which is either a primitive or a
  complex type already listed in the table.

  Let's now talk about modifiers. You may have noticed that some search
  parameters include a colon followed by another word. That part is called a
  modifier. As the name suggests, it changes the default behavior of the search
  parameter in a specific way. The available modifiers depend on the search
  parameter type, and their use is completely optional. You should use them only
  when needed to fine-tune the behavior of your query:
  | Parameter Type | Modifier                                                                                       |
  |----------------+------------------------------------------------------------------------------------------------|
  | number         | :missing                                                                                       |
  | date           | :missing                                                                                       |
  | string         | :contains, :exact, :missing, :text                                                             |
  | token          | :above, :below, :code-text, :in, :missing, :not, :not-in, :of-type, :text, :text-advanced      |
  | reference      | :above, :below, :code-text, :in, :missing, :not-in, :text, :text-advanced, :identifier, [type] |
  | composite      | ---                                                                                            |
  | quantity       | :missing                                                                                       |
  | uri            | :above, :below, :contains, :missing, :text                                                     |
  | special        | ---                                                                                            |

  Prefixes are another way to modify the behavior of ordered search
  parameters. They can be used to adjust the behavior of ordered search
  parameter types such as number, date and quantity. You can check the available
  prefixes in the table here:
  | Paramter Type | Prefixes                           |
  |---------------+------------------------------------|
  | number        | eq, ne, gt, lt, ge, le, sa, eb, ap |
  | date          | eq, ne, gt, lt, ge, le, sa, eb, ap |
  | string        | ---                                |
  | token         | ---                                |
  | reference     | ---                                |
  | composite     | ---                                |
  | quantity      | eq, ne, gt, lt, ge, le, sa, eb, ap |
  | uri           | ---                                |
  | special       | ---                                |

  Now that we've covered search parameter types, modifiers, and prefixes, we can
  combine them in a table that shows different patterns for how to use them
  together:
  | Parameter Type | Patterns                                                      |
  |----------------+---------------------------------------------------------------|
  | number         | [parameter]{:[modifier]}={[prefix]}[value]{,[value]}          |
  | date           | [parameter]{:[modifier]}={[prefix]}[value]{,[value]}          |
  | string         | [parameter]{:[modifier]}=[value]{,[value]}                    |
  | token          | [parameter]{:[modifier]}={[system]} {[code]}                  |
  | reference      | [parameter]{:[modifier]}={[type]/}[id]{/_history/[version]}   |
  | composite      | [parameter]=[value]$[value]{$[value]}                         |
  | quantity       | [parameter]{:[modifier]}={[prefix]}[number]{[system]}{[code]} |
  | uri            | [parameter]{:[modifier]}=[value]{,[value]}                    |
  | special        | [parameter]=[value]                                           |

* Resource Validation
  It's important to check resources against the FHIR standard and any associated
  profiles during both the creation and processing of FHIR instances. Doing so
  ensures interoperability, which we discussed in the earlier. It also helps
  maintain data quality, supports better health information exchange, and
  catches potential issues before they cause downstream problems.

  When we talk about validation, we're looking at several key aspects that align
  with different levels of interoperability:
  1. Syntax Validation: This step checks whether the FHIR resource follows the
     syntax rules defined by the specification. It involves verifying the
     format - whether it's XML or JSON - and ensuring the structure is
     well-formed and free of syntax errors.
  2. Structure Validation: This means checking whether the resource instance
     matches the expected structure defined in the FHIR standard or in a
     specific implementation guide. We look to see if all required elements are
     present, whether the correct data types are used, and whether constraints,
     like cardinality, are respected.
  3. Terminology Validation: FHIR resources often rely on standardized code
     systems and value sets to express healthcare concepts. This type of
     validation ensures that the codes used are valid, belong to the appropriate
     code system, and are included in the allowed value sets.
  4. Reference Validation: Checks whether those referenced resources actually
     exist and are accessible.
  5. Custom Validation: These are additional requirements specific to a
     particular use case or implementation context, and help ensure the resource
     is valid beyond the base specification. The FHIR specification outlines
     many of these validation approaches in more detail.

* FHIR Terminologies
  In today's healthcare, coded information plays a crucial role in both
  communication and data storage. In FHIR, we refer to this as
  "terminologies". While most parts of the FHIR standard focus on structure,
  FHIR terminology is all about ensuring semantic consistency.

  FHIR terminology refers to standardized sets of codes, concepts, and
  definitions. It allows us to represent clinical information in a structured,
  meaningful way that systems can use together seamlessly.

  In FHIR, terminology-related terms include:
  | Coding concept | Description                                                                                                                                                                                                                      |
  |----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | Terminology    | Within the FHIR framework, the term "terminology" represents any collection of encoded information.                                                                                                                              |
  | Concept Domain | A concept domain is simply a named set of concepts with no associated vocabulary or value set.                                                                                                                                   |
  | Code System    | A code system is a set of standardized concepts or symbols with specific meanings. Most notable code systems are LOINC, SNOMED CT, ICD, etc.                                                                                     |
  | Value Set      | A value set is a collection of codes from one or more coding systems or sub-domains representing a single concept for use in a particular context. Value sets may have subsets which are also considered as separate value sets. |

** Bindings
   Alright, let's talk about something that can make FHIR terminology a bit
   tricky - the mechanism of binding, specifically binding strength. This
   feature applies to all data types that involve coded elements, such as code,
   Coding, and CodeableConcept.

   You'll find binding strength described in all FHIR resource types, and it's
   frequently referenced in implementation guides as well. Here is a table that
   provides a simplified overview of binding strengths and how they apply to
   data types with coded elements:
   | Data Type        | Required                                                                      | Extensible                                                                     | Preferred                                                                                                    | Example                                                                     |
   |------------------+-------------------------------------------------------------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------|
   | code             | SHALL be selected from the specified value set                                | SHOULD be selected from the specified value set                                | SHALL NOT apply to an element with the 'code' data type                                                      | SHALL NOT apply to an element with the 'code' data type                     |
   | Coding           | Coding.system and Coding.value SHALL be selected from the specified value set | Coding.system and Coding.value SHOULD be selected from the specified value set | Coding.system and Coding.value SHOULD be selected from the specified value set, but MAY use other value sets | Coding.system and Coding.value MAY be selected from the specified value set |
   | Codeable Concept | At least one Coding SHALL be selected from the specified value set            | At least one Coding SHOULD be selected from the specified value set            | Coding SHOULD be selected from the specified value set, but MAY use other value sets                         | Coding MAY be selected from the specified value set                         |
